# EasyHash
Easy way to autogenerate GetHashCode and Equals functions.
Very often we have to write straightforward repeating and easy code that can be autogenerated and as result it
eliminate errors introduced during manual typing.

EasyHash generate GetHashCode function with performance close to classic implementation
because it doesn't use reflection. Don't use EasyHash if performance is your primary goal because
there is a slight decrease of performance and if not then it will prevent you from making mistakes.

Code like this:
```
public sealed class HashedManually
{
    ...

    public override int GetHashCode()
    {
        unchecked
        {
            int hash = 2166136261;
            hash = hash * 16780669 ^ (field1 == null ? 0 : field1.GetHashCode());
            hash = hash * 16780669 ^ (field2 == 0 ? 0 : field2.GetHashCode());
            hash = hash * 16780669 ^ (field3 == null ? 0 : field3.GetHashCode());
            hash = hash * 16780669 ^ (field4 == 0 ? 0 : field4.GetHashCode());
            hash = hash * 16780669 ^ (field5 == null ? 0 : field5.GetHashCode());
            hash = hash * 16780669 ^ (field6 == 0 ? 0 : field6.GetHashCode());
            hash = hash * 16780669 ^ (field7 == null ? 0 : field7.GetHashCode());
            var col1Hash = 486187739;
            if (col1 != null){
                for(var item in col1) {
                    col1Hash = col1Hash * 486190561 ^ (item == null ? 0 : item.GetHashCode());
                }
            }
            hash = hash * 16780669 ^ col1Hash;
            return hash;
        }
    }

    private bool Equals(HashedManually other)
    {
        return field1 == other.field1
        && field2 == other.field2
        && string.Equals(field3, other.field3)
        && field4 == other.field4
        && field5 == other.field5
        && field6 == other.field6
        && field7 == other.field7;
    }

    public override bool Equals(object obj)
    {
        if (ReferenceEquals(null, obj)) return false;
        if (ReferenceEquals(this, obj)) return true;
        return obj is HashedManually && Equals((HashedManually) obj);
    }
}

```


can be replaced with just few lines of code:
```
public sealed class HashedWithEasyHash
{
    ...

    public override int GetHashCode() => EasyHash<HashedWithEasyHash>.GetHashCode(this);
    public override bool Equals(object obj) => EasyHash<HashedWithEasyHash>.Equals(this, obj);
}
```

Hashing can be customized with fluent syntaxis:
```
public sealed class HashedWithComplexRegistration
{
	...

	static HashedWithComplexRegistration()
	{
		EasyHash<HashedWithComplexRegistration>
			.Register(r => r
				.WithPrimes(17, 23)
				.Skip(f => f.Number)
				.For(f => f.Numbers, (ob, hash) => ob.Numbers.OrderBy(x=>x).Aggregate(hash, (i, i1) => (i * 23) ^ i1.GetHashCode()))
				.For(f => f.Text, (ob, hash) => (hash * 23) ^ ob.Text.GetHashCode())
				.ExcludeCoolectionItems());
	}

	public override int GetHashCode() => EasyHash<HashedWithComplexRegistration>.GetHashCode(this);
	public override bool Equals(object obj) => EasyHash<HashedWithComplexRegistration>.Equals(this, obj);
}
```
